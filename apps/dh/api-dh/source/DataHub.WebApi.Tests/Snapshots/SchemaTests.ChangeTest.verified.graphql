schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

interface ActorRequestQueryResult implements OrchestrationInstance {
  messageId: String
  calculationType: RequestCalculationType
  period: DateRange
  requestedBy: Actor
  id: UUID!
  createdAt: DateTime!
  scheduledAt: DateTime
  startedAt: DateTime
  terminatedAt: DateTime
  createdBy: AuditIdentityDto
  state: ProcessState!
  steps: [OrchestrationInstanceStep!]!
}

interface Calculation implements OrchestrationInstance {
  executionType: CalculationExecutionType!
  calculationType: CalculationTypeQueryParameterV1!
  id: UUID!
  createdAt: DateTime!
  scheduledAt: DateTime
  startedAt: DateTime
  terminatedAt: DateTime
  createdBy: AuditIdentityDto
  state: ProcessState!
  steps: [OrchestrationInstanceStep!]!
}

interface Error {
  message: String!
}

interface OrchestrationInstance {
  id: UUID!
  createdAt: DateTime!
  scheduledAt: DateTime
  startedAt: DateTime
  terminatedAt: DateTime
  createdBy: AuditIdentityDto
  state: ProcessState!
  steps: [OrchestrationInstanceStep!]!
}

type Actor {
  gridAreas: [GridAreaDto!]!
  publicMail: ActorPublicMail
  contact: ActorContactDto
  status: ActorStatus!
  organization: Organization!
  balanceResponsibleAgreements: [BalanceResponsibilityAgreement!]
  credentials: ActorCredentialsDto!
  auditLogs: [ActorAuditedChangeAuditLogDto!]!
  delegations: [MessageDelegationType!]!
  displayName: String!
  additionalRecipientForMeasurements: [String!]!
  id: UUID!
  name: String!
  glnOrEicNumber: String!
  marketRole: EicFunction!
  userRoles(userId: UUID): [ActorUserRole!]!
}

type ActorAuditedChangeAuditLogDto {
  auditedBy: String
  consolidation: ActorConsolidationAuditLog
  delegation: ActorDelegationAuditLog
  change: ActorAuditedChange!
  timestamp: DateTime!
  isInitialAssignment: Boolean!
  currentValue: String
  previousValue: String
}

type ActorCertificateCredentialsDto {
  thumbprint: String!
  expirationDate: DateTime!
}

type ActorClientSecretCredentialsDto {
  clientSecretIdentifier: UUID!
  expirationDate: DateTime!
}

type ActorClientSecretDto {
  secretText: String!
}

type ActorConsolidationAuditLog {
  currentOwner: String!
  currentOwnerGln: String!
  previousOwner: String
  previousOwnerGln: String!
  previousOwnerStopsAt: DateTime
}

type ActorContactDto {
  contactId: UUID!
  actorId: UUID!
  category: ContactCategory!
  name: String!
  email: String!
  phone: String
}

type ActorCredentialsDto {
  assignCertificateCredentialsUrl(actorId: UUID!): String
  removeActorCredentialsUrl(actorId: UUID!): String
  certificateCredentials: ActorCertificateCredentialsDto
  clientSecretCredentials: ActorClientSecretCredentialsDto
}

type ActorDelegationAuditLog {
  actor: String!
  gln: String!
  startsAt: String!
  stopsAt: String
  gridAreaName: String!
  processType: String!
}

type ActorNameDto {
  value: String!
}

type ActorNameWithId {
  id: UUID!
  actorName: ActorNameDto!
}

type ActorPublicMail {
  mail: String!
}

type ActorUserRole {
  id: UUID!
  name: String!
  status: UserRoleStatus!
  description: String!
  eicFunction: EicFunction!
  assigned: Boolean!
}

type AddMeteringPointsToAdditionalRecipientPayload {
  boolean: Boolean
  errors: [AddMeteringPointsToAdditionalRecipientError!]
}

type AddTokenToDownloadUrlPayload {
  string: String
  errors: [AddTokenToDownloadUrlError!]
}

type AddressDto {
  streetName: String
  number: String
  zipCode: String
  city: String
  country: String!
}

type ApiError implements Error {
  message: String!
  apiErrors: [ApiErrorDescriptor!]!
  statusCode: Int!
  response: String
  headers: [KeyValuePairOfStringAndIEnumerableOfString!]!
}

type ApiErrorDescriptor {
  message: String!
  code: String!
  args: JSON!
}

type ArchivedMessage {
  sender: Actor
  receiver: Actor
  documentUrl: String
  id: String!
  messageId: String!
  documentType: DocumentType!
  createdAt: DateTime!
}

"A connection to a list of items."
type ArchivedMessagesConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [ArchivedMessagesEdge!]
  "A flattened list of the nodes."
  nodes: [ArchivedMessage!]
}

"An edge in a connection."
type ArchivedMessagesEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ArchivedMessage!
}

"A connection to a list of items."
type ArchivedMessagesForMeteringPointConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [ArchivedMessagesForMeteringPointEdge!]
  "A flattened list of the nodes."
  nodes: [ArchivedMessage!]
}

"An edge in a connection."
type ArchivedMessagesForMeteringPointEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ArchivedMessage!
}

type AssociatedActors {
  email: String!
  actors: [UUID!]!
}

type AuditIdentityDto {
  auditIdentityId: UUID!
  displayName: String!
}

type BalanceResponsibilityAgreement {
  gridArea: GridAreaDto
  energySupplierWithName: ActorNameWithId
  balanceResponsibleWithName: ActorNameWithId
  meteringPointType: MarketParticipantMeteringPointType!
  validPeriod: DateRange!
  status: BalanceResponsibilityAgreementStatus!
}

type BalanceResponsible {
  storageDocumentUrl: String
  gridArea: GridAreaDto
  energySupplierName: String
  balanceResponsibleName: String
  validPeriod: DateRange!
  id: String!
  receivedDateTime: DateTime!
  supplier: String!
  balanceResponsible: String!
  meteringPointType: BalanceResponsibilityMeteringPointType!
}

"A segment of a collection."
type BalanceResponsibleCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [BalanceResponsible!]
  balanceResponsiblesUrl(locale: String!): String
  balanceResponsibleImportUrl: String
}

type BalanceResponsiblePageResult {
  page: [BalanceResponsible!]!
  totalCount: Int!
}

type CPRResponse {
  result: String!
}

type CVROrganizationResult {
  name: String!
  hasResult: Boolean!
}

"A connection to a list of items."
type CalculationsConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [CalculationsEdge!]
  "A flattened list of the nodes."
  nodes: [Calculation!]
  capacitySettlementsUploadUrl: String
}

"An edge in a connection."
type CalculationsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Calculation!
}

type CancelMeasurementsReportPayload {
  boolean: Boolean
}

type CancelScheduledCalculationPayload {
  boolean: Boolean
}

type CancelSettlementReportPayload {
  boolean: Boolean
}

type CapacitySettlementCalculation implements Calculation & OrchestrationInstance {
  yearMonth: YearMonth!
  executionType: CalculationExecutionType!
  calculationType: CalculationTypeQueryParameterV1!
  id: UUID!
  createdAt: DateTime!
  scheduledAt: DateTime
  startedAt: DateTime
  terminatedAt: DateTime
  createdBy: AuditIdentityDto
  state: ProcessState!
  steps: [OrchestrationInstanceStep!]!
}

"Information about the offset pagination."
type CollectionSegmentInfo {
  "Indicates whether more items exist following the set defined by the clients arguments."
  hasNextPage: Boolean!
  "Indicates whether more items exist prior the set defined by the clients arguments."
  hasPreviousPage: Boolean!
}

type CommercialRelationDto {
  hadElectricalHeating: Boolean!
  haveElectricalHeating: Boolean!
  electricalHeatingStartDate: DateTime
  energySupplierName: ActorNameDto
  id: Long!
  energySupplier: String!
  startDate: DateTime!
  endDate: DateTime!
  activeEnergySupplyPeriod: EnergySupplyPeriodDto
  energySupplyPeriodTimeline: [EnergySupplyPeriodDto!]!
  activeElectricalHeatingPeriods: ElectricalHeatingDto
  electricalHeatingPeriods: [ElectricalHeatingDto!]!
}

type CreateCalculationPayload {
  uuid: UUID
}

type CreateDelegationsForActorPayload {
  boolean: Boolean
  errors: [CreateDelegationsForActorError!]
}

type CreateMarketParticipantPayload {
  boolean: Boolean
  errors: [CreateMarketParticipantError!]
}

type CreateUserRolePayload {
  boolean: Boolean
  errors: [CreateUserRoleError!]
}

type CustomerContactDto {
  id: Long!
  name: String
  email: String
  isProtectedAddress: Boolean!
  phone: String
  mobile: String
  attention: String
  streetCode: String
  streetName: String
  buildingNumber: String
  postCode: String
  cityName: String
  citySubDivisionName: String
  darReference: UUID
  countryCode: String
  floor: String
  room: String
  postBox: String
  municipalityCode: String
}

type CustomerDto {
  id: Long!
  name: String!
  cvr: String
  isProtectedName: Boolean!
  legalContact: CustomerContactDto
  technicalContact: CustomerContactDto
}

type DeactivateUserPayload {
  boolean: Boolean
  errors: [DeactivateUserError!]
}

type DeactivateUserRolePayload {
  boolean: Boolean
  errors: [DeactivateUserRoleError!]
}

type DismissNotificationPayload {
  boolean: Boolean
  errors: [DismissNotificationError!]
}

type ElectricalHeatingCalculation implements Calculation & OrchestrationInstance {
  executionType: CalculationExecutionType!
  calculationType: CalculationTypeQueryParameterV1!
  id: UUID!
  createdAt: DateTime!
  scheduledAt: DateTime
  startedAt: DateTime
  terminatedAt: DateTime
  createdBy: AuditIdentityDto
  state: ProcessState!
  steps: [OrchestrationInstanceStep!]!
}

type ElectricalHeatingDto {
  id: Long!
  validFrom: DateTime!
  validTo: DateTime!
}

type EnergySupplyPeriodDto {
  id: Long!
  validFrom: DateTime!
  validTo: DateTime!
  customers: [CustomerDto!]!
}

"A segment of a collection."
type EsettExchangeEventsCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [ExchangeEventSearchResult!]
  gridAreaCount: Int!
}

type EsettOutgoingMessage {
  dispatchDocumentUrl: String
  responseDocumentUrl: String
  gridArea: GridAreaDto
  period: DateRange!
  documentId: String!
  created: DateTime!
  gridAreaCode: String!
  calculationType: ExchangeEventCalculationType!
  timeSeriesType: EsettTimeSeriesType!
  documentStatus: DocumentStatus!
  lastDispatched: DateTime
  manuallyHandledExchangeEventMetaData: ManuallyHandledExchangeEventMetaData
}

type ExchangeEventSearchResult {
  gridArea: GridAreaDto
  energySupplier: ActorNameDto
  documentId: String!
  actorNumber: String
  gridAreaCodeOut: String
  created: DateTime!
  calculationType: ExchangeEventCalculationType!
  timeSeriesType: EsettTimeSeriesType!
  documentStatus: DocumentStatus!
  lastDispatched: DateTime
}

type ExchangeEventStatusReportResponse {
  waitingForExternalResponse: Int!
}

"A connection to a list of items."
type FilteredPermissionsConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [FilteredPermissionsEdge!]
  "A flattened list of the nodes."
  nodes: [Permission!]
  permissionRelationsUrl: String
}

"An edge in a connection."
type FilteredPermissionsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Permission!
}

"A connection to a list of items."
type FilteredUserRolesConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [FilteredUserRolesEdge!]
  "A flattened list of the nodes."
  nodes: [UserRoleDto!]
}

"An edge in a connection."
type FilteredUserRolesEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: UserRoleDto!
}

type GridAreaAuditedChangeAuditLogDto {
  auditedBy: String
  currentOwner: String
  previousOwner: String
  consolidatedAt: DateTime
  change: GridAreaAuditedChange!
  timestamp: DateTime!
  isInitialAssignment: Boolean!
  currentValue: String
  previousValue: String
}

type GridAreaDto {
  includedInCalculation: Boolean!
  id: UUID!
  code: String!
  name: String!
  priceAreaCode: PriceAreaCode!
  type: GridAreaType!
  validFrom: DateTime!
  validTo: DateTime
  displayName: String!
  status: GridAreaStatus!
}

type GridAreaOverviewItemDto {
  actor: String!
  auditLog: [GridAreaAuditedChangeAuditLogDto!]!
  id: UUID!
  code: String!
  name: String!
  priceAreaCode: PriceAreaCode!
  validFrom: DateTime!
  validTo: DateTime
  actorNumber: String
  actorName: String
  organizationName: String
  fullFlexDate: DateTime
  type: GridAreaType!
  displayName: String!
  status: GridAreaStatus!
}

"Imbalance price"
type ImbalancePrice {
  priceAreaCode: PriceAreaCode!
  timestamp: DateTime!
  price: Float
}

"Imbalance price for a given date"
type ImbalancePriceDaily {
  status: ImbalancePriceStatus!
  imbalancePricesDownloadImbalanceUrl: String!
  timeStamp: DateTime!
  imbalancePrices: [ImbalancePrice!]!
  importedAt: DateTime
}

type ImbalancePricePeriod {
  name: DateTime!
  priceAreaCode: PriceAreaCode!
  status: ImbalancePriceStatus!
}

type ImbalancePricesOverview {
  uploadImbalancePricesUrl: String!
  pricePeriods: [ImbalancePricePeriod!]!
}

type InitiateMitIdSignupPayload {
  boolean: Boolean
  errors: [InitiateMitIdSignupError!]
}

type InstallationAddressDto {
  id: Long!
  streetCode: String
  streetName: String!
  buildingNumber: String!
  cityName: String!
  citySubDivisionName: String
  darReference: UUID
  washInstructions: WashInstructions
  countryCode: String!
  floor: String
  room: String
  postCode: String!
  municipalityCode: String
  locationDescription: String
}

type InviteUserPayload {
  boolean: Boolean
  errors: [InviteUserError!]
}

type KeyValuePairOfStringAndIEnumerableOfString {
  key: String!
  value: [String!]!
}

type KeyValuePairOfStringAndListOfSettlementReportApplicableCalculation {
  key: String!
  value: [RequestSettlementReportGridAreaCalculation!]!
}

type ManuallyHandleOutgoingMessagePayload {
  boolean: Boolean
}

type ManuallyHandledExchangeEventMetaData {
  manuallyHandledByIdentityDisplayName: String!
  comment: String!
  manuallyHandledAt: DateTime!
  manuallyHandledBy: UUID!
}

type MeasurementAggregationByDateDto {
  date: Date
  quantity: Decimal
  qualities: [Quality!]!
  unit: Unit!
  isMissingValues: Boolean!
  containsUpdatedValues: Boolean!
}

type MeasurementAggregationByMonthDto {
  yearMonth: YearMonth!
  quantity: Decimal
  unit: Unit!
}

type MeasurementAggregationByYearDto {
  year: Int!
  quantity: Decimal
  unit: Unit!
}

type MeasurementDto {
  measurementPositions: [MeasurementPositionDto!]!
}

type MeasurementPointDto {
  order: Int!
  quantity: Decimal
  quality: Quality!
  unit: Unit!
  resolution: Resolution!
  persistedTime: DateTime!
  registrationTime: DateTime!
}

type MeasurementPositionDto {
  current: MeasurementPointDto
  hasQuantityOrQualityChanged: Boolean!
  resolution: Resolution!
  historic: [MeasurementPointDto!]!
  index: Int!
  observationTime: DateTime!
  measurementPoints: [MeasurementPointDto!]!
}

type MeasurementsReport {
  period: DateRange!
  statusType: MeasurementsReportStatusType!
  measurementsReportDownloadUrl: String
  actor: Actor
  id: String!
  requestedByActorId: UUID!
  gridAreaCodes: [String!]!
  createdDateTime: DateTime!
  meteringPointTypes: [MeasurementsReportMeteringPointType!]
}

type MergeMarketParticipantsPayload {
  boolean: Boolean
  errors: [MergeMarketParticipantsError!]
}

type MessageDelegationType {
  gridArea: GridAreaDto
  delegatedBy: Actor
  delegatedTo: Actor
  periodId: UUID!
  id: UUID!
  process: DelegatedProcess!
  validPeriod: DateRange!
  status: ActorDelegationStatus!
}

type MeteringGridAreaImbalancePerDayDto {
  imbalanceDay: DateTime!
  firstOccurrenceOfImbalance: DateTime!
  firstPositionOfImbalance: Int!
  quantity: Float!
}

type MeteringGridAreaImbalanceSearchResponse {
  items: [MeteringGridAreaImbalanceSearchResult!]!
  totalCount: Int!
}

type MeteringGridAreaImbalanceSearchResult {
  gridArea: GridAreaDto
  mgaImbalanceDocumentUrl: String
  period: DateRange!
  id: String!
  documentDateTime: DateTime!
  receivedDateTime: DateTime!
  incomingImbalancePerDay: [MeteringGridAreaImbalancePerDayDto!]!
  outgoingImbalancePerDay: [MeteringGridAreaImbalancePerDayDto!]!
}

type MeteringPointDto {
  meteringPointId: String!
  isChild: Boolean!
  isEnergySupplier(energySupplierActorGln: String!): Boolean!
  isGridAccessProvider(gridAccessProviderActorGln: String!): Boolean!
  id: Long!
  identification: String!
  metadata: MeteringPointMetadataDto!
  metadataTimeline: [MeteringPointMetadataDto!]!
  commercialRelation: CommercialRelationDto
  commercialRelationTimeline: [CommercialRelationDto!]!
}

type MeteringPointIdentificationDto {
  identification: String!
}

type MeteringPointMetadataDto {
  gridArea: GridAreaDto
  fromGridArea: GridAreaDto
  toGridArea: GridAreaDto
  id: Long!
  validFrom: DateTime!
  validTo: DateTime!
  parentMeteringPoint: String
  type: ElectricityMarketMeteringPointType!
  subType: MeteringPointSubType
  connectionState: ConnectionState
  resolution: String!
  ownedBy: String!
  connectionType: ConnectionType
  disconnectionType: DisconnectionType
  product: Product
  productObligation: Boolean
  measureUnit: MeteringPointMeasureUnit!
  assetType: AssetType
  environmentalFriendly: Boolean
  capacity: String
  powerLimitKw: Float
  meterNumber: String
  netSettlementGroup: Int
  scheduledMeterReadingMonth: Int
  powerPlantGsrn: String
  settlementMethod: SettlementMethod
  installationAddress: InstallationAddressDto
}

type MeteringPointsGroupByPackageNumber {
  packageNumber: String!
  meteringPoints: [MeteringPointIdentificationDto!]!
}

type MissingMeasurementsLogCalculation implements Calculation & OrchestrationInstance {
  executionType: CalculationExecutionType!
  calculationType: CalculationTypeQueryParameterV1!
  id: UUID!
  createdAt: DateTime!
  scheduledAt: DateTime
  startedAt: DateTime
  terminatedAt: DateTime
  createdBy: AuditIdentityDto
  state: ProcessState!
  steps: [OrchestrationInstanceStep!]!
}

type Mutation {
  resendWaitingEsettExchangeMessages: ResendWaitingEsettExchangeMessagesPayload!
  manuallyHandleOutgoingMessage(input: ManuallyHandleOutgoingMessageInput!): ManuallyHandleOutgoingMessagePayload!
  mergeMarketParticipants(input: MergeMarketParticipantsInput!): MergeMarketParticipantsPayload!
  dismissNotification(input: DismissNotificationInput!): DismissNotificationPayload!
  addTokenToDownloadUrl(input: AddTokenToDownloadUrlInput!): AddTokenToDownloadUrlPayload!
  updateUserProfile(input: UpdateUserProfileInput!): UpdateUserProfilePayload!
  updateUserIdentity(input: UpdateUserIdentityInput!): UpdateUserIdentityPayload!
  inviteUser(input: InviteUserInput!): InviteUserPayload!
  reInviteUser(input: ReInviteUserInput!): ReInviteUserPayload!
  resetTwoFactorAuthentication(input: ResetTwoFactorAuthenticationInput!): ResetTwoFactorAuthenticationPayload!
  deactivateUser(input: DeactivateUserInput!): DeactivateUserPayload!
  reActivateUser(input: ReActivateUserInput!): ReActivateUserPayload!
  initiateMitIdSignup: InitiateMitIdSignupPayload!
  sendMeasurements(input: SendMeasurementsRequestV1Input!): Boolean! @authorize(roles: [ "measurements:manage" ])
  updateActor(input: UpdateActorInput!): UpdateActorPayload!
  createMarketParticipant(input: CreateMarketParticipantInput!): CreateMarketParticipantPayload!
  createDelegationsForActor(input: CreateDelegationsForActorInput!): CreateDelegationsForActorPayload!
  stopDelegation(input: StopDelegationInput!): StopDelegationPayload!
  requestClientSecretCredentials(input: RequestClientSecretCredentialsInput!): RequestClientSecretCredentialsPayload!
  addMeteringPointsToAdditionalRecipient(input: AddMeteringPointsToAdditionalRecipientInput!): AddMeteringPointsToAdditionalRecipientPayload!
  removeMeteringPointsFromAdditionalRecipient(input: RemoveMeteringPointsFromAdditionalRecipientInput!): RemoveMeteringPointsFromAdditionalRecipientPayload!
  updateOrganization(input: UpdateOrganizationInput!): UpdateOrganizationPayload!
  updatePermission(input: UpdatePermissionInput!): UpdatePermissionPayload!
  updateUserRoleAssignment(input: UpdateUserRoleAssignmentInput!): UpdateUserRoleAssignmentPayload!
  updateUserRole(input: UpdateUserRoleInput!): UpdateUserRolePayload!
  createUserRole(input: CreateUserRoleInput!): CreateUserRolePayload!
  deactivateUserRole(input: DeactivateUserRoleInput!): DeactivateUserRolePayload!
  requestMeasurementsReport(requestMeasurementsReportInput: RequestMeasurementsReportInput!): RequestMeasurementsReportPayload!
  cancelMeasurementsReport(input: CancelMeasurementsReportInput!): CancelMeasurementsReportPayload!
  createCalculation(input: CreateCalculationInput!): CreateCalculationPayload! @authorize(roles: [ "calculations:manage" ])
  cancelScheduledCalculation(input: CancelScheduledCalculationInput!): CancelScheduledCalculationPayload! @authorize(roles: [ "calculations:manage" ])
  request(input: RequestInput!): RequestPayload! @authorize(roles: [ "request-aggregated-measured-data:view", "request-wholesale-settlement:view" ])
  requestMissingMeasurementsLog(input: RequestMissingMeasurementsLogInput!): RequestMissingMeasurementsLogPayload! @authorize(roles: [ "missing-measurements-log:view" ])
  requestSettlementReport(requestSettlementReportInput: RequestSettlementReportInput!): RequestSettlementReportPayload!
  cancelSettlementReport(input: CancelSettlementReportInput!): CancelSettlementReportPayload!
}

type NetConsumptionCalculation implements Calculation & OrchestrationInstance {
  executionType: CalculationExecutionType!
  calculationType: CalculationTypeQueryParameterV1!
  id: UUID!
  createdAt: DateTime!
  scheduledAt: DateTime
  startedAt: DateTime
  terminatedAt: DateTime
  createdBy: AuditIdentityDto
  state: ProcessState!
  steps: [OrchestrationInstanceStep!]!
}

type NotificationDto {
  notificationType: NotificationType!
  id: Int!
  occurredAt: DateTime!
  expiresAt: DateTime!
  relatedToId: String
}

type OptionOfMeteringPointType {
  value: MeteringPointType!
  displayValue: String!
}

type OptionOfRequestCalculationType {
  value: RequestCalculationType!
  displayValue: String!
}

type OrchestrationInstanceStep {
  state: ProcessStepState!
  isCurrent: Boolean!
}

type Organization {
  auditLogs: [OrganizationAuditedChangeAuditLogDto!]!
  actors: [Actor!]
  id: UUID!
  name: String!
  businessRegisterIdentifier: String!
  domains: [String!]!
  status: String!
  address: AddressDto!
}

type OrganizationAuditedChangeAuditLogDto {
  auditedBy: String
  change: OrganizationAuditedChange!
  timestamp: DateTime!
  isInitialAssignment: Boolean!
  currentValue: String
  previousValue: String
}

"Information about pagination in a connection."
type PageInfo {
  "Indicates whether more edges exist following the set defined by the clients arguments."
  hasNextPage: Boolean!
  "Indicates whether more edges exist prior the set defined by the clients arguments."
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
  "When paginating forwards, the cursor to continue."
  endCursor: String
}

"A connection to a list of items."
type PaginatedOrganizationsConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [PaginatedOrganizationsEdge!]
  "A flattened list of the nodes."
  nodes: [Organization!]
}

"An edge in a connection."
type PaginatedOrganizationsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Organization!
}

type Permission {
  userRoles: [UserRoleDto!]!
  auditLogs: [PermissionAuditedChangeAuditLogDto!]!
  id: Int!
  name: String!
  description: String!
  created: DateTime!
  assignableTo: [EicFunction!]!
}

type PermissionAuditedChangeAuditLogDto {
  auditedBy: String
  change: PermissionAuditedChange!
  timestamp: DateTime!
  isInitialAssignment: Boolean!
  currentValue: String
  previousValue: String
}

type PermissionDetailsDto {
  id: Int!
  name: String!
  description: String!
  created: DateTime!
}

"A connection to a list of items."
type ProcessesConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [ProcessesEdge!]
  "A flattened list of the nodes."
  nodes: [OrchestrationInstance!]
}

"An edge in a connection."
type ProcessesEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: OrchestrationInstance!
}

type Query {
  imbalancePricesOverview: ImbalancePricesOverview!
  imbalancePricesForMonth(year: Int! month: Int! areaCode: PriceAreaCode!): [ImbalancePriceDaily!]!
  notifications: [NotificationDto!]!
  releaseToggles: [String!]!
  debugView(meteringPointId: String!): String! @authorize(roles: [ "metering-point:search" ])
  meteringPointsByGridAreaCode(gridAreaCode: String!): [MeteringPointsGroupByPackageNumber!]! @authorize(roles: [ "metering-point:search" ])
  aggregatedMeasurementsForMonth(showOnlyChangedValues: Boolean! query: GetMonthlyAggregateByDateQueryInput!): [MeasurementAggregationByDateDto!]! @authorize(roles: [ "metering-point:search" ])
  aggregatedMeasurementsForYear(query: GetYearlyAggregateByMonthQueryInput!): [MeasurementAggregationByMonthDto!]! @authorize(roles: [ "metering-point:search" ])
  aggregatedMeasurementsForAllYears(query: GetAggregateByYearQueryInput!): [MeasurementAggregationByYearDto!]! @authorize(roles: [ "metering-point:search" ])
  measurements(showOnlyChangedValues: Boolean! query: GetByDayQueryInput!): MeasurementDto! @authorize(roles: [ "metering-point:search" ])
  measurementPoints(observationTime: DateTime! query: GetByDayQueryInput!): [MeasurementPointDto!]! @authorize(roles: [ "metering-point:search" ])
  meteringPointContactCpr(contactId: Long!): CPRResponse! @authorize(roles: [ "metering-point:search" ])
  relatedMeteringPoints(meteringPointId: String!): RelatedMeteringPointsDto! @authorize(roles: [ "metering-point:search" ])
  meteringPoint(meteringPointId: String! enableNewSecurityModel: Boolean! = false): MeteringPointDto! @authorize(roles: [ "metering-point:search" ])
  balanceResponsible(skip: Int take: Int order: BalanceResponsibleSortInput): BalanceResponsibleCollectionSegment
  balanceResponsibleById(documentId: String!): BalanceResponsible!
  esettServiceStatus: [ReadinessStatusDto!]!
  esettExchangeStatusReport: ExchangeEventStatusReportResponse!
  esettExchangeEvents(skip: Int take: Int periodInterval: DateRange createdInterval: DateRange sentInterval: DateRange gridAreaCodes: [String!] calculationType: ExchangeEventCalculationType documentStatuses: [DocumentStatus!] timeSeriesType: EsettTimeSeriesType filter: String actorNumber: String order: EsettExchangeEventSortInput): EsettExchangeEventsCollectionSegment
  downloadEsettExchangeEvents(locale: String! periodInterval: DateRange createdInterval: DateRange sentInterval: DateRange gridAreaCodes: [String!] calculationType: ExchangeEventCalculationType documentStatuses: [DocumentStatus!] timeSeriesType: EsettTimeSeriesType documentId: String actorNumber: String order: EsettExchangeEventSortInput): String!
  esettOutgoingMessageById(documentId: String!): EsettOutgoingMessage!
  meteringGridAreaImbalance(pageNumber: Int! pageSize: Int! createdFrom: DateTime createdTo: DateTime calculationPeriod: DateRange gridAreaCodes: [String!] documentId: String valuesToInclude: MeteringGridImbalanceValuesToInclude! sortProperty: MeteringGridAreaImbalanceSortProperty! sortDirection: SortDirection!): MeteringGridAreaImbalanceSearchResponse!
  downloadMeteringGridAreaImbalance(locale: String! createdFrom: DateTime createdTo: DateTime calculationPeriod: DateRange gridAreaCodes: [String!] documentId: String valuesToInclude: MeteringGridImbalanceValuesToInclude! sortProperty: MeteringGridAreaImbalanceSortProperty! sortDirection: SortDirection!): String!
  selectedActor: Actor!
  actorById(id: UUID!): Actor!
  actors: [Actor!]!
  actorsByOrganizationId(organizationId: UUID!): [Actor!]!
  actorsForEicFunction(eicFunctions: [EicFunction!]): [Actor!]!
  associatedActors(email: String!): AssociatedActors!
  filteredActors: [Actor!]!
  selectionActors: [SelectionActorDto!]!
  gridAreas: [GridAreaDto!]!
  relevantGridAreas(actorId: UUID period: PeriodInput!): [GridAreaDto!]!
  gridAreaOverviewItemById(gridAreaId: UUID!): GridAreaOverviewItemDto!
  gridAreaOverviewItems: [GridAreaOverviewItemDto!]!
  organizationById(id: UUID!): Organization!
  organizations: [Organization!]!
  paginatedOrganizations(filter: String "Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String order: [OrganizationSortInput!]): PaginatedOrganizationsConnection
  searchOrganizationInCVR(cvr: String!): CVROrganizationResult!
  permissionById(id: Int!): Permission!
  filteredPermissions(filter: String "Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String order: [PermissionDtoSortInput!]): FilteredPermissionsConnection
  permissionsByEicFunction(eicFunction: EicFunction!): [PermissionDetailsDto!]!
  domainExists(email: String!): Boolean!
  knownEmails: [String!]!
  userById(id: UUID!): User!
  users(skip: Int take: Int actorId: UUID userRoleIds: [UUID!] userStatus: [UserStatus!] filter: String order: UsersSortInput): UsersCollectionSegment
  userProfile: UserProfile!
  userRolesByActorId(actorId: UUID!): [UserRoleDto!]!
  userRolesByEicFunction(eicFunction: EicFunction!): [UserRoleDto!]!
  filteredUserRoles(status: UserRoleStatus eicFunctions: [EicFunction!] filter: String "Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String order: [UserRoleSortInput!]): FilteredUserRolesConnection
  userRoles(actorId: UUID): [UserRoleDto!]!
  userRoleById(id: UUID!): UserRoleWithPermissions!
  measurementsReports: [MeasurementsReport!]!
  archivedMessagesForMeteringPoint(created: DateRange! meteringPointId: String! senderId: UUID receiverId: UUID documentType: MeteringPointDocumentType "Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String order: ArchivedMessageSortInput): ArchivedMessagesForMeteringPointConnection
  archivedMessages(created: DateRange! senderId: UUID receiverId: UUID documentTypes: [SearchDocumentType!] businessReasons: [BusinessReason!] includeRelated: Boolean filter: String "Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String order: ArchivedMessageSortInput): ArchivedMessagesConnection
  calculationById(id: UUID!): Calculation @authorize(roles: [ "calculations:manage", "calculations:view" ])
  calculations(input: CalculationsQueryInput! filter: String "Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String order: [CalculationSortInput!]): CalculationsConnection @authorize(roles: [ "calculations:manage", "calculations:view" ])
  latestCalculation(calculationType: StartCalculationType! period: PeriodInput!): Calculation @authorize(roles: [ "calculations:manage", "calculations:view" ])
  processes(input: CalculationsQueryInput! filter: String "Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String order: [ProcessSortInput!]): ProcessesConnection @authorize(roles: [ "calculations:manage", "calculations:view" ])
  processById(id: UUID!): OrchestrationInstance!
  requests("Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String order: [RequestSortInput!]): RequestsConnection @authorize(roles: [ "calculations:manage", "request-aggregated-measured-data:view", "request-wholesale-settlement:view" ])
  requestOptions: RequestOptions! @authorize(roles: [ "request-aggregated-measured-data:view", "request-wholesale-settlement:view" ])
  settlementReportById(requestId: ReportRequestIdInput!): SettlementReport!
  settlementReports: [SettlementReport!]!
  settlementReportGridAreaCalculationsForPeriod(calculationType: CalculationType! gridAreaId: [String!]! calculationPeriod: DateRange!): [KeyValuePairOfStringAndListOfSettlementReportApplicableCalculation!]!
}

type ReActivateUserPayload {
  boolean: Boolean
  errors: [ReActivateUserError!]
}

type ReInviteUserPayload {
  boolean: Boolean
  errors: [ReInviteUserError!]
}

type ReadinessStatusDto {
  component: ESettStageComponent!
  isReady: Boolean!
}

type RelatedMeteringPointDto {
  id: Long!
  identification: String!
  type: ElectricityMarketMeteringPointType!
  connectionState: ConnectionState!
  connectionDate: DateTime
  closedDownDate: DateTime
}

type RelatedMeteringPointsDto {
  current: RelatedMeteringPointDto!
  parent: RelatedMeteringPointDto
  relatedMeteringPoints: [RelatedMeteringPointDto!]!
  relatedByGsrn: [RelatedMeteringPointDto!]!
  historicalMeteringPoints: [RelatedMeteringPointDto!]!
  historicalMeteringPointsByGsrn: [RelatedMeteringPointDto!]!
}

type RemoveMeteringPointsFromAdditionalRecipientPayload {
  boolean: Boolean
  errors: [RemoveMeteringPointsFromAdditionalRecipientError!]
}

type RequestCalculatedEnergyTimeSeriesResult implements ActorRequestQueryResult & OrchestrationInstance {
  meteringPointType: MeteringPointType
  messageId: String
  calculationType: RequestCalculationType
  period: DateRange
  requestedBy: Actor
  id: UUID!
  createdAt: DateTime!
  scheduledAt: DateTime
  startedAt: DateTime
  terminatedAt: DateTime
  createdBy: AuditIdentityDto
  state: ProcessState!
  steps: [OrchestrationInstanceStep!]!
}

type RequestCalculatedWholesaleServicesResult implements ActorRequestQueryResult & OrchestrationInstance {
  priceType: PriceType
  messageId: String
  calculationType: RequestCalculationType
  period: DateRange
  requestedBy: Actor
  id: UUID!
  createdAt: DateTime!
  scheduledAt: DateTime
  startedAt: DateTime
  terminatedAt: DateTime
  createdBy: AuditIdentityDto
  state: ProcessState!
  steps: [OrchestrationInstanceStep!]!
}

type RequestClientSecretCredentialsPayload {
  actorClientSecretDto: ActorClientSecretDto
  errors: [RequestClientSecretCredentialsError!]
}

type RequestMeasurementsReportPayload {
  boolean: Boolean
}

type RequestMissingMeasurementsLogPayload {
  boolean: Boolean
}

type RequestOptions {
  calculationTypes: [OptionOfRequestCalculationType!]!
  meteringPointTypes: [OptionOfMeteringPointType!]!
  isGridAreaRequired: Boolean!
}

type RequestPayload {
  boolean: Boolean
}

type RequestSettlementReportGridAreaCalculation {
  calculationId: UUID!
  calculationDate: DateTime!
  gridAreaWithName: GridAreaDto
}

type RequestSettlementReportPayload {
  boolean: Boolean
}

"A connection to a list of items."
type RequestsConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [RequestsEdge!]
  "A flattened list of the nodes."
  nodes: [ActorRequestQueryResult!]
}

"An edge in a connection."
type RequestsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ActorRequestQueryResult!
}

type ResendWaitingEsettExchangeMessagesPayload {
  boolean: Boolean
}

type ResetTwoFactorAuthenticationPayload {
  boolean: Boolean
  errors: [ResetTwoFactorAuthenticationError!]
}

type SelectionActorDto {
  id: UUID!
  gln: String!
  actorName: String!
  organizationName: String!
  marketRole: EicFunction!
}

type SettlementReport {
  period: DateRange!
  statusType: SettlementReportStatusType!
  executionTime: DateRange!
  gridAreas: [String!]!
  settlementReportDownloadUrl: String
  combineResultInASingleFile: Boolean!
  actor: Actor
  id: String!
  requestedByActorId: UUID!
  calculationType: CalculationType!
  numberOfGridAreasInReport: Int!
  includesBasisData: Boolean!
  progress: Float!
  includeMonthlyAmount: Boolean!
}

type StopDelegationPayload {
  boolean: Boolean
  errors: [StopDelegationError!]
}

type Subscription {
  notificationAdded: NotificationDto!
  calculationUpdated: Calculation! @authorize(roles: [ "calculations:manage", "calculations:view" ])
}

type UpdateActorPayload {
  boolean: Boolean
  errors: [UpdateActorError!]
}

type UpdateOrganizationPayload {
  organization: Organization
  errors: [UpdateOrganizationError!]
}

type UpdatePermissionPayload {
  permission: Permission
  errors: [UpdatePermissionError!]
}

type UpdateUserIdentityPayload {
  boolean: Boolean
  errors: [UpdateUserIdentityError!]
}

type UpdateUserProfilePayload {
  boolean: Boolean
  errors: [UpdateUserProfileError!]
}

type UpdateUserRoleAssignmentPayload {
  boolean: Boolean
  errors: [UpdateUserRoleAssignmentError!]
}

type UpdateUserRolePayload {
  boolean: Boolean
  errors: [UpdateUserRoleError!]
}

type User {
  auditLogs: [UserAuditedChangeAuditLogDto!]!
  id: UUID!
  name: String!
  status: UserStatus!
  firstName: String!
  lastName: String!
  email: String!
  phoneNumber: String
  administratedBy: Actor
  createdDate: DateTime!
  latestLoginAt: DateTime
  actors: [Actor!]!
}

type UserAuditedChangeAuditLogDto {
  auditedBy: String
  affectedActorName: String
  affectedUserRoleName: String
  change: UserAuditedChange!
  timestamp: DateTime!
  isInitialAssignment: Boolean!
  currentValue: String
  previousValue: String
}

type UserOverviewItemDto {
  name: String!
  id: UUID!
  status: UserStatus!
  firstName: String!
  lastName: String!
  email: String!
  phoneNumber: String
  createdDate: DateTime!
  administratedBy: Actor
  latestLoginAt: DateTime
  actors: [Actor!]!
}

type UserProfile {
  firstName: String!
  lastName: String!
  phoneNumber: String!
  hasFederatedLogin: Boolean!
}

type UserRoleAuditedChangeAuditLogDto {
  auditedBy: String
  affectedPermissionName: String
  change: UserRoleAuditedChange!
  timestamp: DateTime!
  isInitialAssignment: Boolean!
  currentValue: String
  previousValue: String
}

type UserRoleDto {
  id: UUID!
  name: String!
  description: String!
  eicFunction: EicFunction!
  status: UserRoleStatus!
}

type UserRoleWithPermissions {
  auditLogs: [UserRoleAuditedChangeAuditLogDto!]!
  id: UUID!
  name: String!
  description: String!
  eicFunction: EicFunction!
  status: UserRoleStatus!
  permissions: [PermissionDetailsDto!]!
}

"A segment of a collection."
type UsersCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [UserOverviewItemDto!]
}

type WholesaleAndEnergyCalculation implements Calculation & OrchestrationInstance {
  gridAreas: [GridAreaDto!]!
  period: DateRange!
  executionType: CalculationExecutionType!
  calculationType: CalculationTypeQueryParameterV1!
  id: UUID!
  createdAt: DateTime!
  scheduledAt: DateTime
  startedAt: DateTime
  terminatedAt: DateTime
  createdBy: AuditIdentityDto
  state: ProcessState!
  steps: [OrchestrationInstanceStep!]!
}

union AddMeteringPointsToAdditionalRecipientError = ApiError

union AddTokenToDownloadUrlError = ApiError

union CreateDelegationsForActorError = ApiError

union CreateMarketParticipantError = ApiError

union CreateUserRoleError = ApiError

union DeactivateUserError = ApiError

union DeactivateUserRoleError = ApiError

union DismissNotificationError = ApiError

union InitiateMitIdSignupError = ApiError

union InviteUserError = ApiError

union MergeMarketParticipantsError = ApiError

union ReActivateUserError = ApiError

union ReInviteUserError = ApiError

union RemoveMeteringPointsFromAdditionalRecipientError = ApiError

union RequestClientSecretCredentialsError = ApiError

union ResetTwoFactorAuthenticationError = ApiError

union StopDelegationError = ApiError

union UpdateActorError = ApiError

union UpdateOrganizationError = ApiError

union UpdatePermissionError = ApiError

union UpdateUserIdentityError = ApiError

union UpdateUserProfileError = ApiError

union UpdateUserRoleAssignmentError = ApiError

union UpdateUserRoleError = ApiError

input ActorNameDtoInput {
  value: String!
}

input ActorNumberDtoInput {
  value: String!
}

input AddMeteringPointsToAdditionalRecipientInput {
  actorId: UUID!
  meteringPointIds: [String!]!
}

input AddTokenToDownloadUrlInput {
  downloadUrl: URL!
}

input AddressDtoInput {
  streetName: String
  number: String
  zipCode: String
  city: String
  country: String!
}

input ArchivedMessageSortInput {
  messageId: SortEnumType
  documentType: SortEnumType
  sender: SortEnumType
  receiver: SortEnumType
  createdAt: SortEnumType
}

input BalanceResponsibleSortInput {
  validFrom: SortDirection
  validTo: SortDirection
  receivedDate: SortDirection
}

input CalculationSortInput {
  calculationType: SortEnumType
  status: SortEnumType
  executionType: SortEnumType
  period: SortEnumType
  executionTime: SortEnumType
}

input CalculationsQueryInput {
  gridAreaCodes: [String!]
  state: ProcessState
  executionType: CalculationExecutionType
  calculationTypes: [CalculationTypeQueryParameterV1!]
  period: DateRange
}

input CancelMeasurementsReportInput {
  requestId: ReportRequestIdInput!
}

input CancelScheduledCalculationInput {
  calculationId: UUID!
}

input CancelSettlementReportInput {
  requestId: ReportRequestIdInput!
}

input CreateActorContactDtoInput {
  name: String!
  category: ContactCategory!
  email: String!
  phone: String
}

input CreateActorGridAreaInput {
  id: UUID!
  meteringPointTypes: [String!]!
}

input CreateActorInput {
  organizationId: UUID!
  name: ActorNameDtoInput!
  actorNumber: ActorNumberDtoInput!
  marketRole: CreateActorMarketRoleInput!
}

input CreateActorMarketRoleInput {
  eicFunction: EicFunction!
  gridAreas: [CreateActorGridAreaInput!]!
  comment: String
}

input CreateCalculationInput {
  executionType: CalculationExecutionType!
  scheduledAt: DateTime
  calculationType: StartCalculationType!
  period: PeriodInput!
  gridAreaCodes: [String!]
}

input CreateDelegationsForActorInput {
  delegations: CreateProcessDelegationsInput!
}

input CreateMarketParticipantInput {
  organizationId: UUID
  organization: CreateOrganizationDtoInput
  actor: CreateActorInput!
  actorContact: CreateActorContactDtoInput!
}

input CreateOrganizationDtoInput {
  name: String!
  businessRegisterIdentifier: String!
  address: AddressDtoInput!
  domains: [String!]!
}

input CreateProcessDelegationsInput {
  delegatedFrom: UUID!
  delegatedTo: UUID!
  gridAreaIds: [UUID!]!
  delegatedProcesses: [DelegatedProcess!]!
  startsAt: DateTime!
}

input CreateUserRoleDtoInput {
  name: String!
  description: String!
  status: UserRoleStatus!
  eicFunction: EicFunction!
  permissions: [Int!]!
}

input CreateUserRoleInput {
  userRole: CreateUserRoleDtoInput!
}

input DeactivateUserInput {
  userId: UUID!
}

input DeactivateUserRoleInput {
  roleId: UUID!
}

input DismissNotificationInput {
  notificationId: Int!
}

input EsettExchangeEventSortInput {
  calculationType: SortEnumType
  created: SortEnumType
  documentId: SortEnumType
  documentStatus: SortEnumType
  gridAreaCode: SortEnumType
  latestDispatched: SortEnumType
  timeSeriesType: SortEnumType
}

input GetAggregateByYearQueryInput {
  meteringPointId: String!
}

input GetByDayQueryInput {
  meteringPointId: String!
  date: LocalDate!
}

input GetMonthlyAggregateByDateQueryInput {
  meteringPointId: String!
  yearMonth: YearMonth!
}

input GetYearlyAggregateByMonthQueryInput {
  meteringPointId: String!
  year: Int!
}

input InvitationUserDetailsDtoInput {
  firstName: String!
  lastName: String!
  phoneNumber: String!
}

input InviteUserInput {
  userInviteDto: UserInvitationDtoInput!
}

input ManuallyHandleOutgoingMessageInput {
  documentId: String!
  comment: String!
}

input MergeMarketParticipantsInput {
  survivingEntity: UUID!
  discontinuedEntity: UUID!
  mergeDate: DateTime!
}

input OrganizationSortInput {
  name: SortEnumType
  businessRegisterIdentifier: SortEnumType
}

input PeriodInput @oneOf {
  interval: DateRange
  yearMonth: YearMonth
}

input PermissionDtoSortInput {
  id: SortEnumType
  name: SortEnumType
  description: SortEnumType
  created: SortEnumType
}

input ProcessSortInput {
  id: SortEnumType
  scheduledAt: SortEnumType
  terminatedAt: SortEnumType
  state: SortEnumType
  createdAt: SortEnumType
  createdBy: SortEnumType
}

input ReActivateUserInput {
  userId: UUID!
}

input ReInviteUserInput {
  userId: UUID!
}

input RemoveMeteringPointsFromAdditionalRecipientInput {
  meteringPointIds: [String!]!
}

input ReportRequestIdInput {
  id: String!
}

input RequestCalculatedEnergyTimeSeriesInput {
  calculationType: RequestCalculationType!
  gridArea: String
  period: PeriodInput!
  meteringPointType: MeteringPointType
}

input RequestCalculatedWholesaleServicesInput {
  calculationType: RequestCalculationType!
  gridArea: String
  period: PeriodInput!
  priceType: PriceType!
}

input RequestClientSecretCredentialsInput {
  actorId: UUID!
}

input RequestInput @oneOf {
  requestCalculatedEnergyTimeSeries: RequestCalculatedEnergyTimeSeriesInput
  requestCalculatedWholesaleServices: RequestCalculatedWholesaleServicesInput
}

input RequestMeasurementsReportInput {
  period: DateRange!
  gridAreaCodes: [String!]!
  resolution: AggregatedResolution!
  energySupplier: String
  requestAsMarketRole: MeasurementsReportMarketRole
  meteringPointTypes: [MeasurementsReportMeteringPointType!]
  requestAsActorId: String
}

input RequestMissingMeasurementsLogInput {
  period: DateRange!
  gridAreaCodes: [String!]!
}

input RequestSettlementReportGridAreaInput {
  calculationId: UUID
  gridAreaCode: String!
}

input RequestSettlementReportInput {
  calculationType: CalculationType!
  period: DateRange!
  gridAreasWithCalculations: [RequestSettlementReportGridAreaInput!]!
  combineResultInASingleFile: Boolean!
  preventLargeTextFiles: Boolean!
  includeMonthlySums: Boolean!
  includeBasisData: Boolean!
  energySupplier: String
  csvLanguage: String
  requestAsActorId: String
  requestAsMarketRole: SettlementReportMarketRole
}

input RequestSortInput {
  messageId: SortEnumType
  state: SortEnumType
  createdAt: SortEnumType
  requestedBy: SortEnumType
  calculationType: SortEnumType
  period: SortEnumType
  meteringPointTypeOrPriceType: SortEnumType
}

input ResetTwoFactorAuthenticationInput {
  userId: UUID!
}

input SendMeasurementsRequestV1Input {
  meteringPointId: String!
  meteringPointType: MeteringPointType2!
  resolution: SendMeasurementsResolution!
  start: DateTime!
  end: DateTime!
  measurements: [SendMeasurementsRequestV1_MeasurementInput!]!
}

input SendMeasurementsRequestV1_MeasurementInput {
  position: Int!
  quantity: Float!
  quality: SendMeasurementsQuality!
}

input StopDelegationInput {
  stopDelegationPeriods: [StopDelegationPeriodInput!]!
}

input StopDelegationPeriodInput {
  delegationId: UUID!
  stopPeriod: StopProcessDelegationDtoInput!
}

input StopProcessDelegationDtoInput {
  periodId: UUID!
  stopsAt: DateTime
}

input UpdateActorInput {
  actorId: UUID!
  actorName: String!
  departmentName: String!
  departmentEmail: String!
  departmentPhone: String!
}

input UpdateActorUserRolesInput {
  actorId: UUID!
  assignments: UpdateUserRoleAssignmentsDtoInput!
}

input UpdateOrganizationInput {
  orgId: UUID!
  domains: [String!]!
}

input UpdatePermissionInput {
  id: Int!
  description: String!
}

input UpdateUserIdentityInput {
  userId: UUID!
  userIdentityUpdateDto: UserIdentityUpdateDtoInput!
}

input UpdateUserProfileInput {
  userProfileUpdateDto: UserProfileUpdateDtoInput!
}

input UpdateUserRoleAssignmentInput {
  userId: UUID!
  input: [UpdateActorUserRolesInput!]!
}

input UpdateUserRoleAssignmentsDtoInput {
  added: [UUID!]!
  removed: [UUID!]!
}

input UpdateUserRoleDtoInput {
  name: String!
  description: String!
  status: UserRoleStatus!
  permissions: [Int!]!
}

input UpdateUserRoleInput {
  userRoleId: UUID!
  userRole: UpdateUserRoleDtoInput!
}

input UserIdentityUpdateDtoInput {
  firstName: String!
  lastName: String!
  phoneNumber: String!
}

input UserInvitationDtoInput {
  email: String!
  invitationUserDetails: InvitationUserDetailsDtoInput
  assignedActor: UUID!
  assignedRoles: [UUID!]!
}

input UserProfileUpdateDtoInput {
  firstName: String!
  lastName: String!
  phoneNumber: String!
}

input UserRoleSortInput {
  name: SortEnumType
  eicFunction: SortEnumType
  status: SortEnumType
}

input UsersSortInput {
  name: SortEnumType
  email: SortEnumType
  phoneNumber: SortEnumType
  latestLoginAt: SortEnumType
  status: SortEnumType
}

enum ActorAuditedChange {
  NAME
  STATUS
  CONTACT_NAME
  CONTACT_EMAIL
  CONTACT_PHONE
  CONTACT_CATEGORY_ADDED
  CONTACT_CATEGORY_REMOVED
  CERTIFICATE_CREDENTIALS
  CLIENT_SECRET_CREDENTIALS
  DELEGATION_START
  DELEGATION_STOP
  CONSOLIDATION_REQUESTED
  CONSOLIDATION_COMPLETED
  ADDITIONAL_RECIPIENT_METERING_POINT_ADDED
  ADDITIONAL_RECIPIENT_METERING_POINT_REMOVED
}

enum ActorDelegationStatus {
  AWAITING
  ACTIVE
  EXPIRED
  CANCELLED
}

enum ActorStatus {
  New
  Active
  Inactive
  Passive
  ToBeDiscontinued
  Discontinued
}

enum AggregatedResolution {
  ACTUAL_RESOLUTION
  SUM_OF_DAY
  SUM_OF_MONTH
}

"Defines when a policy shall be executed."
enum ApplyPolicy {
  "Before the resolver was executed."
  BEFORE_RESOLVER
  "After the resolver was executed."
  AFTER_RESOLVER
  "The policy is applied in the validation step before the execution."
  VALIDATION
}

enum AssetType {
  STEAM_TURBINE_WITH_BACK_PRESSURE_MODE
  GAS_TURBINE
  COMBINED_CYCLE
  COMBUSTION_ENGINE_GAS
  STEAM_TURBINE_WITH_CONDENSATION_STEAM
  BOILER
  STIRLING_ENGINE
  PERMANENT_CONNECTED_ELECTRICAL_ENERGY_STORAGE_FACILITIES
  TEMPORARILY_CONNECTED_ELECTRICAL_ENERGY_STORAGE_FACILITIES
  FUEL_CELLS
  PHOTO_VOLTAIC_CELLS
  WIND_TURBINES
  HYDROELECTRIC_POWER
  WAVE_POWER
  MIXED_PRODUCTION
  PRODUCTION_WITH_ELECTRICAL_ENERGY_STORAGE_FACILITIES
  POWER_TO_X
  REGENERATIVE_DEMAND_FACILITY
  COMBUSTION_ENGINE_DIESEL
  COMBUSTION_ENGINE_BIO
  NO_TECHNOLOGY
  UNKNOWN_TECHNOLOGY
}

"Represents the status of a balance responsibility agreement."
enum BalanceResponsibilityAgreementStatus {
  AWAITING
  ACTIVE
  SOON_TO_EXPIRE
  EXPIRED
}

enum BalanceResponsibilityMeteringPointType {
  MgaExchange
  Production
  Consumption
}

enum BusinessReason {
  D03
  D04
  D05
  D32
}

enum CalculationExecutionType {
  EXTERNAL
  INTERNAL
}

enum CalculationType {
  BALANCE_FIXING
  AGGREGATION
  WHOLESALE_FIXING
  FIRST_CORRECTION_SETTLEMENT
  SECOND_CORRECTION_SETTLEMENT
  THIRD_CORRECTION_SETTLEMENT
}

enum CalculationTypeQueryParameterV1 {
  BALANCE_FIXING
  AGGREGATION
  WHOLESALE_FIXING
  FIRST_CORRECTION_SETTLEMENT
  SECOND_CORRECTION_SETTLEMENT
  THIRD_CORRECTION_SETTLEMENT
  ELECTRICAL_HEATING
  CAPACITY_SETTLEMENT
  NET_CONSUMPTION
  MISSING_MEASUREMENTS_LOG
}

enum ConnectionState {
  NOT_USED
  CLOSED_DOWN
  NEW
  CONNECTED
  DISCONNECTED
}

enum ConnectionType {
  DIRECT
  INSTALLATION
}

enum ContactCategory {
  DEFAULT
  CHARGES
  CHARGE_LINKS
  ELECTRICAL_HEATING
  END_OF_SUPPLY
  ENERGINET_INQUIRY
  ERROR_REPORT
  INCORRECT_MOVE
  INCORRECT_SWITCH
  MEASUREMENT_DATA
  METERING_POINT
  NET_SETTLEMENT
  NOTIFICATION
  RECON
  REMINDER
}

enum DelegatedProcess {
  REQUEST_ENERGY_RESULTS
  RECEIVE_ENERGY_RESULTS
  REQUEST_WHOLESALE_RESULTS
  RECEIVE_WHOLESALE_RESULTS
  REQUEST_METERING_POINT_DATA
  RECEIVE_METERING_POINT_DATA
  SEND_METERING_POINT_DATA
  RECEIVE_GAP_LOG
}

enum DisconnectionType {
  REMOTE_DISCONNECTION
  MANUAL_DISCONNECTION
}

enum DocumentStatus {
  RECEIVED
  AWAITING_DISPATCH
  AWAITING_REPLY
  ACCEPTED
  REJECTED
  BIZ_TALK_ACCEPTED
  MANUALLY_HANDLED
}

enum DocumentType {
  ACKNOWLEDGEMENT
  NOTIFY_VALIDATED_MEASURE_DATA
  REQUEST_MEASUREMENTS
  REJECT_REQUEST_MEASUREMENTS
  NOTIFY_AGGREGATED_MEASURE_DATA
  REJECT_REQUEST_AGGREGATED_MEASURE_DATA
  REQUEST_AGGREGATED_MEASURE_DATA
  B2C_REQUEST_AGGREGATED_MEASURE_DATA
  REJECT_REQUEST_WHOLESALE_SETTLEMENT
  REQUEST_WHOLESALE_SETTLEMENT
  B2C_REQUEST_WHOLESALE_SETTLEMENT
  NOTIFY_WHOLESALE_SERVICES
  REMINDER_OF_MISSING_MEASUREMENTS
}

enum ESettStageComponent {
  CONVERTER
  SENDER
  RECEIVER
}

enum EicFunction {
  BalanceResponsibleParty
  BillingAgent
  EnergySupplier
  GridAccessProvider
  ImbalanceSettlementResponsible
  MeterOperator
  MeteredDataAdministrator
  MeteredDataResponsible
  MeteringPointAdministrator
  SystemOperator
  DanishEnergyAgency
  DataHubAdministrator
  IndependentAggregator
  SerialEnergyTrader
  Delegated
  ItSupplier
}

enum ElectricityEicFunctionType {
  BalanceResponsibleParty
  BillingAgent
  EnergySupplier
  GridAccessProvider
  ImbalanceSettlementResponsible
  MeterOperator
  MeteredDataAdministrator
  MeteredDataResponsible
  MeteringPointAdministrator
  SystemOperator
  DanishEnergyAgency
  DataHubAdministrator
  IndependentAggregator
  SerialEnergyTrader
  Delegated
  ItSupplier
}

enum ElectricityMarketMeteringPointType {
  Consumption
  Production
  Exchange
  VEProduction
  Analysis
  NotUsed
  SurplusProductionGroup6
  NetProduction
  SupplyToGrid
  ConsumptionFromGrid
  WholesaleServicesOrInformation
  OwnProduction
  NetFromGrid
  NetToGrid
  TotalConsumption
  NetLossCorrection
  ElectricalHeating
  NetConsumption
  OtherConsumption
  OtherProduction
  CapacitySettlement
  ExchangeReactiveEnergy
  CollectiveNetProduction
  CollectiveNetConsumption
  ActivatedDownregulation
  ActivatedUpregulation
  ActualConsumption
  ActualProduction
  InternalUse
}

enum EsettTimeSeriesType {
  MgaExchange
  Production
  Consumption
}

enum ExchangeEventCalculationType {
  BALANCE_FIXING
  AGGREGATION
}

enum GridAreaAuditedChange {
  NAME
  CONSOLIDATION_REQUESTED
  CONSOLIDATION_COMPLETED
  DECOMMISSIONED
}

enum GridAreaStatus {
  Created
  Active
  Expired
  Archived
  ToBeDiscontinued
}

enum GridAreaType {
  NotSet
  Transmission
  Distribution
  Other
  Test
  GridLossDK
  GridLossAbroad
  Aboard
}

enum ImbalancePriceStatus {
  NO_DATA
  IN_COMPLETE
  COMPLETE
}

enum MarketParticipantMeteringPointType {
  Unknown
  D01VeProduction
  D02Analysis
  D03NotUsed
  D04SurplusProductionGroup6
  D05NetProduction
  D06SupplyToGrid
  D07ConsumptionFromGrid
  D08WholeSaleServicesInformation
  D09OwnProduction
  D10NetFromGrid
  D11NetToGrid
  D12TotalConsumption
  D13NetLossCorrection
  D14ElectricalHeating
  D15NetConsumption
  D17OtherConsumption
  D18OtherProduction
  D20ExchangeReactiveEnergy
  D99InternalUse
  E17Consumption
  E18Production
  E20Exchange
}

enum MeasurementsReportMarketRole {
  GRID_ACCESS_PROVIDER
  ENERGY_SUPPLIER
  DATA_HUB_ADMINISTRATOR
}

enum MeasurementsReportMeteringPointType {
  Consumption
  Production
  Exchange
  VeProduction
  NetProduction
  SupplyToGrid
  ConsumptionFromGrid
  WholesaleServicesInformation
  OwnProduction
  NetFromGrid
  NetToGrid
  TotalConsumption
  ElectricalHeating
  NetConsumption
  CapacitySettlement
  Analysis
  OtherConsumption
  OtherProduction
  ExchangeReactiveEnergy
  CollectiveNetProduction
  CollectiveNetConsumption
  ActivatedDownRegulation
  ActivatedUpRegulation
  ActualConsumption
  ActualProduction
}

enum MeasurementsReportStatusType {
  IN_PROGRESS
  ERROR
  COMPLETED
  CANCELED
}

enum MeteringGridAreaImbalanceSortProperty {
  DOCUMENT_DATE_TIME
  GRID_AREA_CODE
  DOCUMENT_ID
  RECEIVED_DATE_TIME
}

enum MeteringGridImbalanceValuesToInclude {
  IMBALANCES
  BALANCES
  BOTH
}

enum MeteringPointDocumentType {
  ACKNOWLEDGEMENT
  FORWARD_MEASUREMENTS
  REQUEST_MEASUREMENTS
  REJECT_REQUEST_MEASUREMENTS
}

enum MeteringPointMeasureUnit {
  AMPERE
  STK
  KV_ARH
  K_WH
  KW
  MW
  M_WH
  TONNE
  MV_AR
  DANISH_TARIFF_CODE
}

enum MeteringPointSubType {
  PHYSICAL
  VIRTUAL
  CALCULATED
}

enum MeteringPointType {
  ALL
  PRODUCTION
  FLEX_CONSUMPTION
  TOTAL_CONSUMPTION
  NON_PROFILED_CONSUMPTION
  EXCHANGE
}

enum MeteringPointType2 {
  CONSUMPTION
  PRODUCTION
  EXCHANGE
  VE_PRODUCTION
  ANALYSIS
  SURPLUS_PRODUCTION_GROUP6
  NET_PRODUCTION
  SUPPLY_TO_GRID
  CONSUMPTION_FROM_GRID
  WHOLESALE_SERVICES_INFORMATION
  OWN_PRODUCTION
  NET_FROM_GRID
  NET_TO_GRID
  TOTAL_CONSUMPTION
  OTHER_CONSUMPTION
  OTHER_PRODUCTION
  EXCHANGE_REACTIVE_ENERGY
  COLLECTIVE_NET_PRODUCTION
  COLLECTIVE_NET_CONSUMPTION
  INTERNAL_USE
}

enum NotificationType {
  BalanceResponsibilityValidationFailed
  BalanceResponsibilityActorUnrecognized
  SettlementReportReadyForDownload
  SettlementReportFailed
  NewBalanceResponsibilityReceived
  MeteringGridAreaIsImbalanced
  ActorCredentialsExpiring
  ActorConsolidationScheduled
}

enum OrganizationAuditedChange {
  DOMAIN
  NAME
}

enum PermissionAuditedChange {
  CLAIM
  DESCRIPTION
}

enum PriceAreaCode {
  DK1
  DK2
}

enum PriceType {
  TARIFF
  SUBSCRIPTION
  FEE
  TARIFF_SUBSCRIPTION_AND_FEE
  MONTHLY_TARIFF
  MONTHLY_SUBSCRIPTION
  MONTHLY_FEE
  MONTHLY_TARIFF_SUBSCRIPTION_AND_FEE
}

enum ProcessState {
  scheduled
  pending
  running
  failed
  canceled
  succeeded
}

enum ProcessStepState {
  pending
  running
  failed
  skipped
  canceled
  succeeded
}

enum Product {
  TARIFF
  FUEL_QUANTITY
  POWER_ACTIVE
  POWER_REACTIVE
  ENERGY_ACTIVE
  ENERGY_REACTIVE
}

enum Quality {
  MISSING
  ESTIMATED
  CALCULATED
  MEASURED
}

enum RequestCalculationType {
  AGGREGATION
  BALANCE_FIXING
  WHOLESALE_FIXING
  FIRST_CORRECTION_SETTLEMENT
  SECOND_CORRECTION_SETTLEMENT
  THIRD_CORRECTION_SETTLEMENT
  LATEST_CORRECTION_SETTLEMENT
}

enum Resolution {
  QUARTER_HOURLY
  HOURLY
  DAILY
  MONTHLY
  YEARLY
}

enum SearchDocumentType {
  B2C_REQUEST_AGGREGATED_MEASURE_DATA
  B2C_REQUEST_WHOLESALE_SETTLEMENT
  NOTIFY_AGGREGATED_MEASURE_DATA
  NOTIFY_WHOLESALE_SERVICES
  REJECT_REQUEST_AGGREGATED_MEASURE_DATA
  REJECT_REQUEST_WHOLESALE_SETTLEMENT
  REQUEST_AGGREGATED_MEASURE_DATA
  REQUEST_WHOLESALE_SETTLEMENT
  ACKNOWLEDGEMENT
  REMINDER_OF_MISSING_MEASUREMENTS
}

enum SendMeasurementsQuality {
  ESTIMATED
  MEASURED
}

enum SendMeasurementsResolution {
  MONTHLY
  HOURLY
  QUARTER_HOURLY
}

enum SettlementMethod {
  FLEX_SETTLED
  PROFILED
  NON_PROFILED
}

enum SettlementReportMarketRole {
  GRID_ACCESS_PROVIDER
  ENERGY_SUPPLIER
  SYSTEM_OPERATOR
  DATA_HUB_ADMINISTRATOR
}

enum SettlementReportStatusType {
  IN_PROGRESS
  ERROR
  COMPLETED
  CANCELED
}

enum SortDirection {
  ASC
  DESC
}

enum SortEnumType {
  ASC
  DESC
}

enum StartCalculationType {
  AGGREGATION
  BALANCE_FIXING
  WHOLESALE_FIXING
  FIRST_CORRECTION_SETTLEMENT
  SECOND_CORRECTION_SETTLEMENT
  THIRD_CORRECTION_SETTLEMENT
  CAPACITY_SETTLEMENT
}

enum Unit {
  K_WH
  K_W
  MW
  M_WH
  TONNE
  K_V_ARH
  MV_AR
}

enum UserAuditedChange {
  FIRST_NAME
  LAST_NAME
  PHONE_NUMBER
  STATUS
  INVITED_INTO_ACTOR
  USER_ROLE_ASSIGNED
  USER_ROLE_REMOVED
  USER_ROLE_REMOVED_DUE_TO_DEACTIVATION
  USER_LOGIN_FEDERATION_REQUESTED
  USER_LOGIN_FEDERATED
}

enum UserOverviewSortProperty {
  FirstName
  LastName
  Email
  PhoneNumber
  CreatedDate
  Status
  LatestLoginAt
}

enum UserRoleAuditedChange {
  NAME
  DESCRIPTION
  STATUS
  PERMISSION_ADDED
  PERMISSION_REMOVED
}

enum UserRoleStatus {
  ACTIVE
  INACTIVE
}

enum UserStatus {
  ACTIVE
  INACTIVE
  INVITED
  INVITE_EXPIRED
}

enum WashInstructions {
  WASHABLE
  NOT_WASHABLE
}

"The authorize directive."
directive @authorize("The name of the authorization policy that determines access to the annotated resource." policy: String "Roles that are allowed to access the annotated resource." roles: [String!] "Defines when when the authorize directive shall be applied.By default the authorize directives are applied during the validation phase." apply: ApplyPolicy! = BEFORE_RESOLVER) repeatable on OBJECT | FIELD_DEFINITION

"""
The `@oneOf` directive is used within the type system definition language
 to indicate:

 - an Input Object is a Oneof Input Object, or
 - an Object Type's Field is a Oneof Field.
"""
directive @oneOf on INPUT_OBJECT

"The `@specifiedBy` directive is used within the type system definition language to provide a URL for specifying the behavior of custom scalar definitions."
directive @specifiedBy("The specifiedBy URL points to a human-readable specification. This field will only read a result for scalar types." url: String!) on SCALAR

"The `Date` scalar represents an ISO-8601 compliant date type."
scalar Date

"Represents a date range"
scalar DateRange

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime @specifiedBy(url: "https:\/\/www.graphql-scalars.com\/date-time")

"The `Decimal` scalar type represents a decimal floating-point number."
scalar Decimal

scalar JSON

"""
LocalDate represents a date within the calendar, with no reference to a particular time zone or time of day.

Allowed patterns:
- `YYYY-MM-DD`

Examples:
- `2000-01-01`
"""
scalar LocalDate

"Represents a long"
scalar Long

scalar URL @specifiedBy(url: "https:\/\/tools.ietf.org\/html\/rfc3986")

scalar UUID @specifiedBy(url: "https:\/\/tools.ietf.org\/html\/rfc4122")

"Represents a year and month"
scalar YearMonth